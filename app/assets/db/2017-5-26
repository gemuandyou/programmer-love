{
  "noteData": "<pre><pre><pre><pre><pre><pre><pre><pre><pre><pre><pre><pre><pre><pre><pre><pre><pre><pre><pre><pre><pre><pre><pre><pre><pre><pre><span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h1</span>-《实战Java高并发程序设计》读书笔记 <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@hr</span>- \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h2</span>-名词\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>临界区  被多个线程使用的公共资源或说是共享数据。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>阻塞、非阻塞  一个线程要使用临界区资源，不巧的是另一个线程占用了这个资源，那么这个线程就会等待导致线程挂起，形成阻塞。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>死锁   两个或多个线程之间相互占用了要使用的资源，导致同时挂起，一直等不到。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>饥饿   线程一直无法获取所需资源，导致一直无法进行。比如它的优先级太低，高优先级的一直抢占它的资源。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>活锁  两个线程需要同一个资源，它们互相谦让，A说你用吧，B说你用吧，都主动将资源释放给别人使用，导致资源在它们两个\\\n线程中来回跳动，没有一个线程可以同时拿到所有资源而正常执行。 \n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h2</span>-阻塞  当使用<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>synchronized  或者<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-red-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>重入锁  的时候，会再执行后续代码前，尝试得到临界区的资源，如果得不到就会挂起,\\\n直到得到所需资源。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h2</span>-无饥饿 线程是有优先级的，所以对于同一个临界区资源来说，不同优先级的线程得到临界区资源是不公平的。这里会涉及到<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>公平锁  \\\n与<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>非公平锁 ，公平锁就是不论线程优先级是高是低，大家公平竞争资源。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h2</span>-无障碍 无障碍是一种最弱的非阻塞调度。因为多个线程不会因为临界区争夺问题导致一方被挂起。大家可以一起进入临界区。但是如果大家一起修改了、\n临界区的共享数据，那么对于无障碍的线程来说，就会立即回滚。\n但是当临界区中存在严重冲突的时候，所有线程可能都会不断的回滚，而没有一个线程走出临界区。那么我们怎么实现这种无障碍呢？\n一种可行的方式是使用一个标记。在线程进入临界区前，读取这个标记，如果进入临界区后有线程修改了临界区资源，那么在修改前先修改这个标记、\n表示数据不再安全，当线程出来的时候，发现这个标记被修改过，说明资源可能在操作过程中与其他写线程冲突，需要重新操作。、\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fc</span>-blue-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>因为当前线程也会修改这个标记，所以可以将这个标记值修改为当前线程的ID之类的东西。 \n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h2</span>-无锁 无锁的并行都是无障碍的。所有线程都能访问临界区，大家同时修改临界区资源，如果有一个资源在<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-有限步内 修改成功，就会走出临界区，其他的就会、\n冲突，不断尝试修改。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h2</span>-无等待 无锁是要求一个线程子啊有限步内完成操作，而无等待则要求所有线程都必需在有限步内完成。他的基本思路是对数据的读不加控制，大家一起读、\n取临界区的资源不会引起任何冲突，在写数据的时候，先取原始数据的副本，对副本进行修改，而原始数据不变，在修改完后，再在合适的时机回写数据。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h2</span>-JMM(JAVA内存模型) <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@i</span>-保证多个线程间可以有效地、正确地协同工作。 JMM的关键技术都是围绕多线程的<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>原子性、可见性、有序性   来建立的。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h3</span>-原子性 原子性是指一个操作是不可中断的。比如一个静态全局变量int i, 两个线程同时对它赋值，i的值要么是第一个线程的值，要么是第二个的。不可能同时进行赋值。\n但是long型的话就可能不行了，对于32位系统来说，long型是64位的，所以它不是原子性的，两线程同时进行写入，线程之间的结果会有干扰。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h3</span>-可见性 当一个线程修改了某一个共享变量的时候，其他线程可以马上知道这个改动，这就是可见性。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fc</span>-blue-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>可见性问题示例1： CPU1和CPU2各运行了一个线程，它们共享一个变量，而CPU1线程将这个变量进行了优化，存入了缓存或寄存器中。当CPU2线程修改了、\n这个变量的时候，CPU1线程还去缓存中拿到了旧的值。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fc</span>-blue-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>可见性问题示例2： 指令重排。在多线程中，编译器在编译指令的时候可能会将写好的指令顺序打乱。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h3</span>-有序性 在只有一个线程的情况下，代码都是按先后顺序执行的。但是在多线程的情况下，程序的执行顺序可能会出现乱序。如下代码：\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>-java-@[\nclass OrderDemo {\n    int a = 0;\n    boolean flag = false;\n\n    public void set() {\n        a = 1;\n        flag = true;\n    }\n\n    public int get() {\n        if (flag) {\n            return a++;\n        }\n        return a;\n    }\n}\nclass MyThread implements Runnable {\n\n    final OrderDemo orderDemo;\n\n    MyThread(OrderDemo orderDemo) {\n        this.orderDemo = orderDemo;\n    }\n\n    @Override\n    public void run() {\n        orderDemo.set();\n    }\n}\npublic class Test {\n    public static void main(String[] args) throws InterruptedException {\n        OrderDemo orderDemo = new OrderDemo();\n        new Thread(new MyThread(orderDemo)).start();\n        System.out.println(&amp;quot;get()=&amp;quot; + orderDemo.get());\n    }\n}]@ \\\n会发现结果<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>get()=0  说明set()方法是在get()方法后执行的，或者严格说是<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>if(flag)  是在<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>flag=true  之前执行的。\n如果我们这样写：<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>-java-@[OrderDemo orderDemo = new OrderDemo();\n        new Thread(new MyThread(orderDemo)).start();\n        <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fc</span>-red-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>Thread.sleep(1000);\n         System.out.println(&amp;quot;get()=&amp;quot; + orderDemo.get());]@ 就会发现结果是<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>get()=1 。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-lightyellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>问题来了，为什么指令要重排呢？这个时候我们就要说一下汇编指令的执行过程了，指令的执行过程是流水线的方式执行。因为不同的指令可能要调用不同的硬件来完成，所以只要等待第一个指令的第一步完成后，我们就可以执行第二条指令了。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-不进行指令重排的情况\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@ul</span>-(#一个线程内的语句是顺序执行的#<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>volatile  volatile变量的写先发生于读，保证了volatile变量的可见性。<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fc</span>-blue-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>用volatile修饰的变量只能保正从主内存加载到线程内存中的值是最新的 、#锁规则：解锁（unlock）必然发生在随后的加锁（lock）前#线程的start()方法先于它的每个动作#线程的所有操作先于线程的终结（Thread.join()）#线程的中断（interrupt()）先于被中断线程的代码#对象的构造函数执行和结束先于finalize()方法) 、\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>-volatile关键字原理|lightyellow-@[Volatile变量是一种被削弱的同步机制。用来确保变量的更新操作会通知到其他线程。\n当把变量用volatile修饰后，编译和运行时都会注意到这个变量是共享的，因此不会进行指令重排。\nvolatile变量不会被缓存到寄存器或其他CPU不可见的地方，因此读取volatile变量的是否总会返回最新值。\n在访问volatile变量的时候不会加锁，因此不会导致线程阻塞，所以说它比sychronized关键字更轻量级。\n当对普通变量进行读写的时候，每个线程会从内存拷贝变量到CPU cache中，对于多个CPU的机器，每个线程可能不在同一个CPU上，所以普通变量被缓存到不同的CPU cache中。\n而volatile修饰的变量保证了即使来自不同CPU的线程都从内存中读取变量的最新值。\n但是，volatile不能保证在多个线程同时修改这个volatile变量的时候（线程不安全的时候）保证原子性。它不能代替锁。]@ \n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h2</span>-线程的操作\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h3</span>-创建线程 <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>-java-@[new Thread().start(); // 方式1\n/**方式2*/\nclass MyThread implements Runable {\n    @Override\n    public void run() {}\n}\nnew Thread(new MyThread()).start();]@ \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h3</span>-线程的终止 <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@i</span>-调用线程的<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>stop()   方法，强制终止一个正在运行的线程，不推荐使用，会释放锁，产生数据安全问题。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h3</span>-线程的中断\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>-java-@[public void Thread.interrupt() // 中断线程\npublic boolean Thread.isInterrupted() // 判断是否被中断\npublic static boolean Thread.interrupted() // 静态方法，判断您是否被中断，并清除当前中断状态]@ &lt;div style=\"height:10px;width: 100%;\"&gt;&lt;/div&gt; \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@tip</span>-@[线程调用interrupt()方法后，只是标记线程被中断，并不会结束执行，需要使用isInterrupted()方法判断状态，然后增加处理中断的代码。sleep()方法调用后，若该进程中断，就会抛出异常。]@ 、\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h3</span>-等待(wait）和通知（notify）\n用于多个线程之间协作。<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>wait()、notify()  这两个方法不在Thread类中，而是在Object中。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>wait()  方法使线程在某个对象上等待。<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>notify()  方法唤醒等待的线程。比如：线程A中，调用了\\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>obj.wait()  那么线程A就会停止继续执行，转为等待状态。当某个线程调用了<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>obj.notify()  方法后，会唤醒、\nA线程继续执行。但是现实中并不一定只有一个线程，在多线程中，如果多个线程都调用了<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>obj.wait()  那么它们都会进入\\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-obj对象  的等待队列中。当某一个线程调用<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>obj.notify()  后，会随机选择一个线程继续执行，而这个随机选择和线程优先级是没有关系的。、\n如果要唤醒<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-obj对象  等待队列中的全部线程。可以调用<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>obj.notifyAll() 。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@tip</span>-@[<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>wait()  方法不是随便调用的，它必须在synchronzied语句中，无论<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>wait()、notify()  都要获得目标对象的一个监视器（锁）。\n在A线程执行<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>wait()  方法前，需要获取obj对象的监视器。执行完wait()方法后释放这个监视器，这样做是为了防止因为A线程的休眠导致全部等待在obj对象上的线程无法正常执行。\n当B线程执行<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>notify()  方法前，也需要获取obj对象的监视器。执行完后，会唤醒一个线程（假设唤醒了A线程），A线程被唤醒后，不会立即执行下面的代码，而是会重新获取obj的监视器，直到获取成功后，才会继续执行。&lt;br&gt;\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fc</span>-red-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>注意： <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>sleep()  也可以让线程等待，但是它不会释放监视器。]@\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h3</span>-挂起（suspend）和继续执行（resume）\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@i</span>-已经被废弃了。这两个方法是组合使用的。  被废弃的原因是因为被挂起的线程不会释放监视器（锁），所以其他线程无法获取到它占用的资源。只能等待该线程调用<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-resume() 方法。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h3</span>-等待线程结束（join）和谦让（yield）\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h4</span>-join() 这个方法有两种形式。<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@ul</span>-(#<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>join()  无线等待，一直阻塞当前线程，直到调用join()的线程执行完毕。#<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>join(long&amp;nbsp;millis)  等待是有限度的。到了时间我不管你有没有执行完，当前线程都会继续走。) 、\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@tip</span>-@[<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-thread1.join()  的本质还是调用 <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-thread1  (线程的实例对象) 的 <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-wait()  方法。当线程执行完成后，会调用 <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-thread1.notifyAll()  唤醒所有thread1等待队列上的线程。所以我们最好不要在线程对象中使用 <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-wait()  和 <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-notify() 。]@ 、\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-这里我有一点儿理解上的困难。所以在这里提示一下自己： <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>-java|lightyellow-@[\npsvm { // 主函数\n    System.out.println(1);\n    thread1.join(); // 这里会执行线程thread1，而当前线程会一直等待。\n    System.out.println(2); // 只有thread1线程执行完成后，才会执行这里\n}\n]@ 、\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h4</span>-yield()\n这是个有趣的方法。它是线程的静态方法。Thread.yield() 的调用表示当前线程让出CPU。但是并不表示当前线程被挂起了，它还会去和其他线程争夺\\\nCPU的使用权。\n如果你觉得一个线程不太重要，害怕他会占用太多CPU资源，可以在适当的时候调用Thread.yield()。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h3</span>-线程组\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@i</span>-就是将相同功能的线程放在一个线程组里。 在创建线程的时候，Thread的构造器第二个参数就是指明线程组。（不信你可以试试啊）\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>activeCount()  可以获得活动线程总数。由于线程是动态的，所以这是一个估计值。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>list()  可以打印这个线程组中的所有线程信息，对调试有些帮助。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>stop()  可以终止线程组中的所有线程。但是和 Thread.stop() 一样，它会释放锁，产生数据安全问题。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h3</span>-守护线程\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@i</span>-守护线程相对的就是用户线程。目的就是为了守护用户线程，为用户线程默默地做一些事情。比如JVM的垃圾回收线程、JIT线程。\n当守护线程守护的用户线程执行完成后，守护线程守护的对象已经不存在了，那么它就不会继续工作了。可以使用<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>thread.setDaemon(true) \\\n 将普通线程设置为守护线程。\n举个栗子：在一个main函数中创建一个守护线程，守护线程的run()方法会进行一个死循环打印，当这个main函数所在的当前线程执行完成后，守护线程、\n就不会打印了。<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fc</span>-red-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>只得注意的是： 在设置守护线程的时候，一定要在守护线程调用<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>start()  方法前调用<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>setDaemon(true) 。 \n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h3</span>-线程的优先级\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@i</span>-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fc</span>-red-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>设置了线程的优先级后，优先级高的线程只是比优先级低的线程更容易抢到资源而已，这个是看   <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-概率 <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@i</span>-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fc</span>-red-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>的，运气不好一直抢不到也是可能的。\n设置优先级的方法：<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-lightgray-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>thread.setPriority(Thread.MAX_PRIORITY); \n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h3</span>-synchronized的三种使用方式\n前景摘要：实现线程安全的静态变量 i 的递增。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>-第一种-@[synchronized(instance) { i++; }]@ \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>-第二种-@[public synchronized void increase() { i++; }]@ \\\n这种方式，不能保证多个实例对象对于静态变量 i 的线程安全。需要使用第三种方式。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"edit-span\">@code</span>-第三种-@[public static synchronized(instance) { i++; }]@\\\nso on 2.8.2 61p</pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre>",
  "noteName": "2017-5-26"
}