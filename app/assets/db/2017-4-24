{
  "noteData": "<pre><span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h1</span>-Docker <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@hr</span>- \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@i</span>-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@url</span>-[https://docs.docker.com/]Official&amp;nbsp;Document   、<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@i</span>-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@url</span>-[http://www.runoob.com/docker/docker-tutorial.html]菜鸟教程   、<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@i</span>-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@url</span>-[http://www.open-open.com/lib/view/open1423703640748.html]一个中文教程\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h2</span>-Docker简介\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h3</span>-Docker结构\n<span contenteditable=\"false\" style=\"color: rgb(0, 192, 255);\">@img</span>-[app/assets/db/img/1496978811851.png] \n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h3</span>-Docker客户端\n就是一些docker的二进制程序，用于用户和docker进行交互，接收用户指令和docker守护进程通讯。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h3</span>-Docker服务器\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h4</span>-Docker守护进程\ndocker的守护进程用户处理用户发出的指令。完成用户和docker的交互。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h4</span>-Docker镜像\n用于创建docker容器，每个镜像都有一堆层（layers)构成。在知乎上看到<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@url</span>-[https://www.zhihu.com/question/25394149/answer/30671258]一篇文章 。比喻的很好，镜像就像Photoshop里的层一样，每个层包含一些东西，用的时候把用到的合到一起构成一个新的镜像。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h4</span>-Docker容器\ndocker镜像创建好了以后，如果要运行，就要创建一个docker容器来运行。可以说docker容器就是用来运行应用程序的，可以运行、停止、删除和修改等操作。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h3</span>-Docker仓库\n就是用来保存docker镜像的地方。可以是本地的，也可以是远程的。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h2</span>-安装\n卸载之前安装的\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; sudo yum remove docker docker-common container-selinux docker-selinux docker-engine]@\\\n安装docker,docker有两个版本，一个花钱，一个不花钱。安装方式有两种，一种是使用仓库安装，一种是使用rpm安装包。\n先说第一种，使用仓库安装。两个版本的仓库安装方式不一样。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-Docker&amp;nbsp;CE\n安装依赖包\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; sudo yum install -y yum-utils device-mapper-persistent-data lvm2]@\\\n添加yum稳定的仓库（stable repository）地址，这个仓库每个季度更新一次Docker CE。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo]@\\\n（可选）添加edge repository 地址，这个默认是禁用的，仓库每个月就更新一次Docker CE。\n启用edge repository\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; sudo yum-config-manager --enable docker-ce-edge]@\\\n禁用edge repository\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; sudo yum-config-manager --disable docker-ce-edge]@\\\n安装\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; sudo yum install docker-ce]@ \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-Docker&amp;nbsp;EE\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@url</span>-[https://docs.docker.com/engine/installation/linux/centos/#install-using-the-repository]看这里，买不起，就没试。\n\n安装好以后，编辑<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>/etc/docker/daemon.json  文件。若没有就创建。并添加如下内容：\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[{\n  &amp;quot;storage-driver&amp;quot;: &amp;quot;devicemapper&amp;quot;\n}]@、\n在生产环境中，必须使用<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>direct-lvm 模式。<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@url</span>-[https://docs.docker.com/engine/userguide/storagedriver/device-mapper-driver/#configure-direct-lvm-mode-for-production]为啥？\n\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h2</span>-基本常用命令汇总\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h6</span>-启动Docker\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; sudo systemctl start docker]@ \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h6</span>-停止Docker\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; systemctl stop docker]@ \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h6</span>-查看Docker镜像列表\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; docker images]@ \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h6</span>-从dockerhub上下载一个ubuntu系统镜像\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; docker pull ubuntu]@\\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h6</span>-导出镜像ubuntu为ubuntu.tar\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; docker save -o ubuntu.tar ubuntu]@\\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h6</span>-载入镜像\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; docker load &lt; ubuntu.tar #或\n&gt; docker load -i ubuntu.tar #貌似不能一次导入多个]@ \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h6</span>-加载镜像，启动一个进程\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; docker run --name 容器名 -d -p 80:80 镜像名（标签）#-p是将本地端口映射到容器中的端口。格式：本地端口:容器端口\n&gt; docker run -it --name 容器名 镜像名 #<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fc</span>-blue-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>-i  让容器的标准输入保持打开 <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fc</span>-blue-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>-t  分配一个伪终端并绑定到容器的标准输入上。 若是没有加其中任意一个参数，启动不起来容器]@ \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h6</span>-容器的导入导出\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"edit-span\">@code</span>--@[&gt; docker export 容器 # 导出容器\n&gt; docker import 容器 # 导入容器]@、\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h6</span>-查看端口映射情况\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; docker port <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fc</span>-green-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>CONTAINER  <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fc</span>-green-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>[PRIVATE_PORT[/PROTO]] ]@\\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h6</span>-查看Docker容器列表\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; docker ps]@ \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h6</span>-删除Docker容器\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; docker rm 容器名/容器ID]@ \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h6</span>-删除Docker镜像\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; docker rmi 镜像ID]@ \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h6</span>-进入Docker容器中\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; docker exec -it 容器名 bash]@ \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@i</span>-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fc</span>-red-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>PS: <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>-it 中i表示interaction，t表示terminal。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; docker attach 容器名 # 只能有一个用户进入容器操作，从容器退出后，容器会停止]@ \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h6</span>-本机与容器之间的文件拷贝\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; docker cp 本机文件路径 container-id:文件路径 #从本机拷到容器里\n&gt; docker cp container-id:文件路径 本机文件路径 #从容器拷到本机]@\\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h6</span>-结束docker容器\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; docker stop 容器ID]@ \\\netc\n\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h2</span>-Docker网络之--net\n--net有四种方式。使用方式：--net=bridge。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@ol</span>-(#<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>bridge  默认方式。容器和主机的网络是连通的。#<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>none  容器没有网络。#<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>host  容器可以访问到主机上的所有网络。#<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>container:容器名/容器ID  多个容器使用共同的网络，他们的IP是一样的。) \n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h2</span>-Docker定制镜像（Dockerfile） <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@hr</span>- \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h3</span>-Dockerfile简介\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-Dockefile的四个部分。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@ul</span>-(#基础镜像信息#维护者信息#镜像操作指令#容器启动执行指令)、\n如：如下创建nginx的Dockerfile：\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[#======第一行必须指定基于的基础镜像======\nFROM docker.io/centos\n\n#======维护者信息======\nMAINTAINER liwei liwei03@camelote.com\n\n#======镜像的操作指令======\n#将主机的nginx拷贝到容器的/usr/local/nginx-1.80目录\nCOPY nginx /usr/local/nginx-1.80\n#安装nginx必要的环境和第三方库\nRUN yum provides '*/applydeltarpm'\nRUN yum install -y applydeltarpm pcre-devel wget net-tools gcc gcc-c++ zlib zlib-devel make openssl-devel\n#RUN yum install -y gcc-c++\n#RUN yum install -y pcre pcre-devel\n#RUN yum install -y zlib zlib-devel\n#RUN yum install -y openssl openssl-devel\n#创建nginx临时文件所需要的目录,\nRUN mkdir -p /usr/local/nginx\n#对nignx进行配置\nRUN cd /usr/local/nginx-1.80 &amp;amp;&amp;amp; ./configure --prefix=/usr/local/nginx &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install\n#配置nginx以前台方式进行启动\nRUN echo &amp;quot;daemon off;&amp;quot;&amp;gt;&amp;gt;/usr/local/nginx/conf/nginx.conf \nEXPOSE 80\n\n#======容器启动时执行的命令======\n#配置容器启动后执行的命令，ENTRYPOINT只能有一个，多个的时候只有最后一个生效\nENTRYPOINT /usr/local/nginx/sbin/nginx\n#CMD /usr/local/nginx/sbin/nginx #也可以使用这个命令，这两命令啥区别，下面会说到]@ 下面是手动创建elasticsearch的Dockerfile（当然你可以直接使用elasticsearch官方镜像）：\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[# 基础镜像\nFROM centos\n# 维护者信息\nMAINTAINER gemu\n# 操作指令\nCOPY package/* /tmp/ # 将主机目录中此Dockerfile文件所在目录下的/package下的所有文件复制到容器的/tmp中\nRUN set -ax \\\n        &amp;amp;&amp;amp; mkdir -p /home/software/ \\\n        &amp;amp;&amp;amp; tar -zxvf /tmp/jdk-8u73-linux-x64.tar.gz -C /home/software \\\n        &amp;amp;&amp;amp; cd /home/software \\\n        &amp;amp;&amp;amp; mv jdk1.8.0_73 jdk1.8 \\\n\n        &amp;amp;&amp;amp; mkdir -p /home/software/elasticsearch/ \\\n        &amp;amp;&amp;amp; mv /tmp/elasticsearch-2.4.5.zip /home/software/elasticsearch \\\n        &amp;amp;&amp;amp; cd /home/software/elasticsearch \\\n        &amp;amp;&amp;amp; yum install -y unzip zip \\\n        &amp;amp;&amp;amp; unzip elasticsearch-2.4.5.zip \\\n        &amp;amp;&amp;amp; awk '{$1~gsub(/# cluster.name: my-application/, &amp;quot;cluster.name: es-demo1&amp;quot;)}1' ./elasticsearch-2.4.5/config/elasticsearch.yml 1&amp;lt;&amp;gt;./elasticsearch-2.4.5/config/elasticsearch.yml\n# java环境变量\nENV JAVA_HOME /home/software/jdk1.8\nENV JRE_HOME /usr/java/jdk1.8/jre\nENV PATH $PATH:$JAVA_HOME/bin:$JRE_HOME/bin\nENV CLASSPATH .:$JAVA_HOME/lib/jt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib\n\nVOLUMN /usr/share/elasticsearch/data\n\nWORKDIR /home/software/elasticsearch/elasticsearch-2.4.5/bin\n\nENTRYPOINT ./elasticsearch -Des.insecure.allow.root=true\n\nHEALTHCHECK CMD curl localhost:9200/_cat/health]@\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h3</span>-指令\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h4</span>-FROM指令\n指定基础镜像，以一个镜像为基础，在这个基础镜像上进行定制。一个Dockerfile中FORM是必须的指令，并且必须是第一个指令。如果想用一个空白的基础镜像，可以使用<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>scratch ，scratch表示一个空白镜像。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h4</span>-MAINTAINER指令\n指定维护者信息。格式：MAINTAINER &amp;lt;name&amp;gt;\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h4</span>-RUN指令\n用于在容器中执行命令。有两种格式：<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@ol</span>-(#shell格式：<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-gray-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>RUN&amp;nbsp;&lt;命令&gt;  就像在命令行中输入命令一样。#exec格式：<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-gray-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>RUN&amp;nbsp;[\"可执行命令\",\"参数1\",\"参数2\"]) \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@i</span>-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fc</span>-red-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>PS:   Dockerfile中每一个指令就会建立一层镜像，如： <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; RUN apt-get update\n&gt; RUN make -C /usr/src/redis]@ 创建了两层，完全没有意义，平白增加了构建部署的时间。所以应该这么写：\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; RUN apt-get update  \\\n&amp;&amp; make -C /usr/src/redis]@ \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h4</span>-EXPOSE指令\n告诉Docker服务端容器暴露的端口号，供系统互联使用。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h4</span>-COPY指令\n将从构建上下文目录中的&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置。格式：<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-#f2f2f2-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>COPY&amp;nbsp;&lt;源路径&gt;...&lt;目标路径&gt; 、 <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-#f2f2f2-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>COPY&amp;nbsp;[\"&lt;源路径1&gt;\",...\"&lt;目标路径&gt;\"] 。源路径可以是多个，可以是通配符（Go的filepath.Match）\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h4</span>-ADD指令（不推荐）\nADD指令和COPY的格式和功能基本一样。只不过在COPY上增加了一些功能。ADD中的&lt;源文件路径&gt;可以使用一个URL，Docker引擎会去下载文件放到&lt;目标路径&gt;。\\\n如果&lt;源文件&gt;为一个tar压缩文件的话，压缩格式为gzip、bzip2、xz，ADD指令会自动解压缩这个压缩文件到&lt;目标路径&gt;。如果需要直接复制个压缩文件到&lt;目标路径&gt;那就只能用COPY了。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fc</span>-red-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>总结： 所有文件复制均使用COPY，仅在需要自动解压缩的场合使用ADD。&lt;源文件路径&gt;可以是docker容器外的上下文路径，也就是说可以将docker外的文件拷贝到docker容器内。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h4</span>-ENV指令\n这个指令就是配置个环境变量。 如配置JAVA_HOME环境变量：<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[ENV JAVA_HOME /software/jdk7]@  \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h4</span>-CMD指令\n用于指定默认的容器主进程的启动命令。也有两种格式：shell和exec，推荐使用exec，shell的本质就是exec，如：\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[CMD echo $HOME]@等价于<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[CMD [\"sh\",\"-c\",\"echo $HOME\"]]@ \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h4</span>-ENTRYPOINT指令\n和CMD目的一样，都是指定容器启动程序及参数。来看下CMD和ENTRYPOINT两个指令的使用场景。\n我们要得知当前公网IP。那么可以用CMD实现：\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[RROM ubuntu:16.04\nRUN apt-get update \\\n&amp;&amp; apt-get install -y curl \\\n&amp;&amp; rm -rf /var/lib/apt/lists/*\nCMD [\"curl\",\"-s\",\"http://ip.cn\"]]@ \\\n运行<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; docker build -t seeip .\n&gt; docker run seeip]@ \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>-result-@[当前 IP：124.202.xxx.110 来自：北京市 鹏博士]@\n但是当我们需要展示HTTP头信息的时候，需要在curl中添加<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>-i  参数。\n如果这样加是肯定不行的：<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; docker run seeip -i]@ 因为镜像名seeip后面是<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>command  ，运行时<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>-i  会替换Dockerfile中的CMD值。\n我们需要在Dockerfile中这样写<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[CMD [\"curl\",\"-s\",\"http://ip.cn\",\"-i\"]]@ \\\n在我们不修改Dockerfile的情况下，我们可以直接把CMD替换为ENTRYPOINT：\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[RROM ubuntu:16.04\nRUN apt-get update \\\n&amp;&amp; apt-get install -y curl \\\n&amp;&amp; rm -rf /var/lib/apt/lists/*\nENTRYPOINT [\"curl\",\"-s\",\"http://ip.cn\"]]@ \\\n这样我们就可以使用<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>docker&amp;nbsp;run&amp;nbsp;seeip&amp;nbsp;-i  来查看HTTP头信息了。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h4</span>-VOLUME指令\n格式：<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@ol</span>-(#VOLUME [\"&amp;lt;路径1&amp;gt;\", \"&amp;lt;路径2&amp;gt;\"...]#VOLUME &amp;lt;路径&amp;gt;)\\\n创建一个可以从本机或其他容器挂载的挂载点，一般存放数据库文件或者需要保持的数据。\n容器运行时应该尽量保持容器存储层不发生写的操作，不然容器删除会导致数据丢失。比如数据库这种需要动态存储数据的应用，数据库文件就应该、\n保存在卷中。这样，即使你删除了这个容器，数据还可以被保留。在<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>/var/lib/docker/volumes/  的子目录中可以找到。\n为了防止运行时忘记将动态文件所保存的目录挂载为卷，所以在Dockerfile中，可以事先指定某些目录挂载为匿名卷。当然运行时可以覆盖、\n这个挂载设置。比如<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[docker run -d -v mysqldata:/data xxxx # 覆盖了Dockerfile中的 <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@i</span>-VOLUME&amp;nbsp;/data]@ \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h4</span>-WORKDIR指令\n指定工作目录( <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@i</span>-当前目录  )。格式：WORKDIR &amp;lt;工作目录路径&amp;gt;\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@tip</span>-@[千万不能把dockerfile等同于shell脚本来编写，因为dockerfile每执行一个命令就会创建一层镜像。比如：\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[RUN cd /data\nRUN echo \"帮助文档\"&gt;readme.md]@ 意图是在/data目录中创建一个内容为”帮助文档“，文件名为readme.md的文件。但是这样事实上会发现找不到/app/readme.md文件。因为<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>RUN&amp;nbsp;cd&amp;nbsp;/data  和<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>RUN&amp;nbsp;echo&amp;nbsp;\"帮助文档\"&gt;readme.md  的执行环境完全不同，他们是在两个不同的容器中。使用这样的操作会造成很多<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fc</span>-blue-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>虚悬镜像 。]@、\n综上所述，我们因该使用<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>WORKDIR  来指定当前目录。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h4</span>-USER指令\n指定当前用户。格式：USER &amp;lt;用户名&amp;gt;\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-USER 可以改变其后执行<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-RUN、CMD和ENTRYPOINT 这类命令的执行身份。当然前提是指定的用户必须是事先建立好的，否则是无法切换成功的。\n使用如下：\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis\nUSER redis\nRUN [\"redis-server\"]]@\\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@i</span>-如果以&amp;nbsp;root&amp;nbsp;执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用&amp;nbsp;su&amp;nbsp;或者&amp;nbsp;sudo&amp;nbsp;, \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@i</span>-这些都需要比较麻烦的配置，而且在&amp;nbsp;TTY（TeleTYpe，虚拟控制台）&amp;nbsp;缺失的环境下经常出错。建议使用&amp;nbsp;gosu&amp;nbsp;，可以从其<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@url</span>-[https://github.com/tianon/gosu]项目网站看到进一步的信息。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[# 建立 redis 用户，并使用 gosu 换另一个用户执行命令\nRUN groupadd -r redis &amp;amp;&amp;amp; useradd -r -g redis redis\n# 下载 gosu\nRUN wget -O /usr/local/bin/gosu &amp;quot;https://github.com/tianon/gosu/\nreleases/download/1.7/gosu-amd64&amp;quot; \\\n&amp;amp;&amp;amp; chmod +x /usr/local/bin/gosu \\\n&amp;amp;&amp;amp; gosu nobody true\n# 设置 CMD，并以另外的用户执行\nCMD [ &amp;quot;exec&amp;quot;, &amp;quot;gosu&amp;quot;, &amp;quot;redis&amp;quot;, &amp;quot;redis-server&amp;quot; ]]@\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h4</span>-HEALTHCHECK指令\n这个指令是检查容器健康状况的命令，在 Docker1.12 引入的。格式：\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@ul</span>-(#HEALTHECK [选项] CMD &lt;命令&gt; : 设置检查容器健康状态的命令#HEALTHCHECK NONE : 如果基础镜像有健康检查指令，使用这个可以屏蔽掉基础镜像的健康检查指令。)\n在1.12版本之前，只能通过容器内的主进程是否正常运行来判断容器状态是否正常。但有些情况，比如某容器内应用的一段程序，没有抛出异常，但是进入了死循环，主进程并不会退出，但是容器内的应用已经不能正常工作了。\n自从有了<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>HEALTHCHECK  指令后，可以通过指定一个命令来判断容器是否正常运行。\n启动容器后，初始状态为<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-#f2f2f2-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>starting  ,在执行健康检查的命令后成功为<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-#f2f2f2-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>healthy  ,失败为<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-#f2f2f2-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>unhealthy  。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>HEALTHCHECK  的<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-选项 有一下几个：\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@ul</span>-(#<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>--interval=&lt;间隔&gt; ：执行健康检查命令的时间间隔。默认30s。#<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>--timeout=&lt;时长&gt; ：执行健康检查命令的超时时间，如果超过这个时间，被视为检查失败，默认30s。#<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>--retries=&lt;次数&gt; ：指定健康检查连续失败多少次后，容器健康状态为<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-f2f2f2-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>unhealty ，默认3次。)\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>HEALTHCHECK  和<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>CMD，ENTRYPOINT  一样，一个Dockerfile里只能出现一次，若多个，只有最后一个生效。\n在<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>HEALTHCHECK&amp;nbsp;[选项]&amp;nbsp;CMD  后面的命令，格式也分为<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>shell、exec  两种格式。命令的返回值为 0 表示失败，返回 1 表示成功。\n使用示例：<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[HEALTHCHECK --interval=60s --timeout=18s \\\n CMD curl -fs http://xxxxx/ || exit 1]@\\\n如上设置了请求间隔为一分钟，超时响应为18秒，使用<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[curl -fs http://xxxxx/ || exit 1]@作为健康检查命令。启动容器后，可以使用<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-f2f2f2-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>docker&amp;nbsp;ps  在运行的容器列表中看到健康状态（unhealthy|healthy）。\n所有的健康检查命令的输出都会被存起来。可以用<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>docker&amp;nbsp;inspect  来查看。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[docker inspect --format '{{json .State.Health}}' web | python\n-m json.tool]@\\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h4</span>-ONBUILD指令\n这个指令后面跟的是其他指令。但是它并不会执行，只有以它作为基础镜像去构建下一级镜像的时候才会被执行。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-比如我们要装多个elasticsearch，并从外面引入配置文件： \n当我们构建Dockerfile的时候，第一个构建完了之后，构建第二个，我们不需要复制Dockerfile了。只需要在基础镜像中这样写就可以了：\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[FROM elasticsearch\nWORKDIR /usr/elasticsearch/\nONBUILD COPY ./elasticsearch.yml ./config\n......]@\n\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h2</span>-Docker构建镜像（build） <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@hr</span>- \\\n写好了Dockerfile后，就可以开始构建镜像了，使用docker build。格式：<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; docker build [选项] &lt;上下文路径/URL/-&gt;]@ 如：\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&amp;gt; docker build -t nginx:3.0 <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fc</span>-red-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>.  ]@ \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@i</span>-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fc</span>-red-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>PS: 注意最后面那个<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>. ，这个点表示的上下文。build后的这个路径可以使用上下文（当前目录）来指定文件，也可以使用一个URL来指定。一般会将Dockerfile也放在上下文下。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h4</span>-使用git repo进行构建\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; docker build https://github.com/xxx.git]@ \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h4</span>-使用tar包进行构建\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; docker build http://www.xx.com/xx.tar.gz]@ \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h4</span>-从标准输入中读取Dockerfile进行构建\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; docker build - &lt; Dockerfile]@ 或 <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[cat Dockerfile | docker build -]@ \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h4</span>-从标准输入中读取上下文压缩包进行构建\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; docker build - &lt; context.tar.gz]@ \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h4</span>-指定某个文件作为Dockerfile构建镜像（默认是上下文中的Dockerfile文件作为Dockerfile）\n主要使用的是docker build中的<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>-f  参数。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; docker build -t seeip @fc-red-&gt;-f  @fc-red-&gt;./demo-dockerfile  .]@ \n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h2</span>-Docker虚悬镜像\n没有仓库名，没有标签&lt;none&gt;，这类镜像一般都已经失去价值的镜像，可以随意删除。\n查看虚悬镜像：<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; docker images -q -f dangling=true]@ \\\n删除虚悬镜像：<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; docker rmi $(docker images -q -f dangling=true)]@\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h2</span>-Docker镜像源配置\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@i</span>-这里使用的是修改docker.service启动参数。当然你也可以使用另一种配置<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>daemon.json   的方式。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@url</span>-[http://www.cnblogs.com/anliven/p/6218741.html]参考1\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@url</span>-[https://cr.console.aliyun.com/]使用aliyun加速器。\n&lt;div&gt;<span contenteditable=\"false\" style=\"color: rgb(0, 192, 255);\">@pre</span>-@[<pre style=\"overflow: auto; border-radius: 0.5rem;padding: 0.5rem;box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 13px; white-space: pre-wrap; display: block; padding: 9.5px; margin: 0px 0px 10px; line-height: 1.42857; color: rgb(51, 51, 51); word-break: break-all; word-wrap: break-word; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); border-radius: 4px;\"><code style=\"box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: inherit; padding: 0px; color: inherit; white-space: pre-wrap; background-color: transparent; border-radius: 0px;\">curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -\n</code></pre><h3 id=\"-docker-\" class=\"ng-scope\" style=\"box-sizing: border-box; font-family: &quot;Helvetica Neue&quot;, &quot;Luxi Sans&quot;, &quot;DejaVu Sans&quot;, Tahoma, &quot;Hiragino Sans GB&quot;, STHeiti, &quot;Microsoft YaHei&quot;; font-weight: 500; line-height: 1.1; color: inherit; margin-top: 20px; margin-bottom: 10px; font-size: 24px;\">如何使用Docker加速器</h3><h4 id=\"-docker-1-10-\" class=\"ng-scope\" style=\"box-sizing: border-box; font-family: &quot;Helvetica Neue&quot;, &quot;Luxi Sans&quot;, &quot;DejaVu Sans&quot;, Tahoma, &quot;Hiragino Sans GB&quot;, STHeiti, &quot;Microsoft YaHei&quot;; font-weight: 500; line-height: 1.1; color: inherit; margin-top: 10px; margin-bottom: 10px; font-size: 18px;\">针对Docker客户端版本大于1.10的用户</h4><p class=\"ng-scope\" style=\"box-sizing: border-box; margin: 0px 0px 10px;\">您可以通过修改daemon配置文件<code style=\"box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; padding: 2px 4px; color: rgb(199, 37, 78); white-space: nowrap; background-color: rgb(249, 242, 244); border-radius: 4px;\">/etc/docker/daemon.json</code>来使用加速器：</p><pre class=\"ng-scope\" style=\"box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 13px; white-space: pre-wrap; display: block; padding: 9.5px; margin: 0px 0px 10px; line-height: 1.42857; color: rgb(51, 51, 51); word-break: break-all; word-wrap: break-word; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); border-radius: 4px;\"><code class=\"ng-binding\" style=\"box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: inherit; padding: 0px; color: inherit; white-space: pre-wrap; background-color: transparent; border-radius: 0px;\">sudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'\n{\n  \"registry-mirrors\": [\"https://33uenx7u.mirror.aliyuncs.com\"]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n</code></pre><h4 id=\"-docker-1-10-\" class=\"ng-scope\" style=\"box-sizing: border-box; font-family: &quot;Helvetica Neue&quot;, &quot;Luxi Sans&quot;, &quot;DejaVu Sans&quot;, Tahoma, &quot;Hiragino Sans GB&quot;, STHeiti, &quot;Microsoft YaHei&quot;; font-weight: 500; line-height: 1.1; color: inherit; margin-top: 10px; margin-bottom: 10px; font-size: 18px;\">针对Docker客户的版本小于等于1.10的用户</h4><p class=\"ng-scope\" style=\"box-sizing: border-box; margin: 0px 0px 10px;\">或者想配置启动参数，可以使用下面的命令将配置添加到<code style=\"box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; padding: 2px 4px; color: rgb(199, 37, 78); white-space: nowrap; background-color: rgb(249, 242, 244); border-radius: 4px;\">docker daemon</code>的启动参数中。</p><ul class=\"ng-scope\" style=\"box-sizing: border-box; margin-top: 0px; margin-bottom: 10px;\"><li style=\"box-sizing: border-box;\">系统要求 CentOS 7 以上，Docker 1.9 以上。<pre style=\"box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 13px; white-space: pre-wrap; display: block; padding: 9.5px; margin: 0px 0px 10px; line-height: 1.42857; color: rgb(51, 51, 51); word-break: break-all; word-wrap: break-word; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); border-radius: 4px;\"><code style=\"box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: inherit; padding: 0px; color: inherit; white-space: pre-wrap; background-color: transparent; border-radius: 0px;\">sudo cp -n /lib/systemd/system/docker.service /etc/systemd/system/docker.service\n</code></pre></li><li style=\"box-sizing: border-box;\">Docker 1.12 以下版本使用 docker daemon 命令<pre style=\"box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 13px; white-space: pre-wrap; display: block; padding: 9.5px; margin: 0px 0px 10px; line-height: 1.42857; color: rgb(51, 51, 51); word-break: break-all; word-wrap: break-word; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); border-radius: 4px;\"><code style=\"box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: inherit; padding: 0px; color: inherit; white-space: pre-wrap; background-color: transparent; border-radius: 0px;\">sudo sed -i \"s|ExecStart=/usr/bin/docker daemon|ExecStart=/usr/bin/docker daemon --registry-mirror=https://qxx96o44.mirror.aliyuncs.com|g\" /etc/systemd/system/docker.service\n</code></pre></li><li style=\"box-sizing: border-box;\">Docker 1.12 及以上版本使用 dockerd 命令<pre style=\"box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 13px; white-space: pre-wrap; display: block; padding: 9.5px; margin: 0px 0px 10px; line-height: 1.42857; color: rgb(51, 51, 51); word-break: break-all; word-wrap: break-word; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); border-radius: 4px;\"><code style=\"box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: inherit; padding: 0px; color: inherit; white-space: pre-wrap; background-color: transparent; border-radius: 0px;\">sudo sed -i \"s|ExecStart=/usr/bin/dockerd|ExecStart=/usr/bin/dockerd --registry-mirror=https://qxx96o44.mirror.aliyuncs.com|g\" /etc/systemd/system/docker.service\nsudo systemctl daemon-reload\nsudo service docker restart\n</code></pre>]@ &lt;/div&gt; 、\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h3</span>-配置镜像源精简篇\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; systemctl enable docker #启用服务\n# 启用成功后会出现如下字样：\n# <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@i</span>-Created&amp;nbsp;symlink&amp;nbsp;from&amp;nbsp;/etc/systemd/system/multi-user.target.wants/docker.service&amp;nbsp;to&amp;nbsp;/etc/systemd/system/docker.service. \n&gt; vi /etc/systemd/system/multi-user.target.wants/docker.service\n# 修改如下内容\nExecStart=/usr/bin/dockerd <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fc</span>-red-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>--registry-mirror=https://33uenx7u.mirror.aliyuncs.com \n&gt; systemctl daemon-reload\n&gt; systemctl restart docker]@ 这就完事了。检验一下。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; ps -ef | grep docker\nroot      14041      1  1 09:08 ?        00:00:00 /usr/bin/dockerd <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>---registry-mirror=https://33uenx7u.mirror.aliyuncs.com \nroot      14044  14041  0 09:08 ?        00:00:00 docker-containerd -l unix:///var/run/docker/libcontainerd/docker-containerd.sock --metrics-inter\nval=0 --start-timeout 2m --state-dir /var/run/docker/libcontainerd/containerd --shim docker-containerd-shim --runtime docker-runc\nroot      14153  13140  0 09:08 pts/1    00:00:00 grep --color=auto docker]@ \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fc</span>-#ff5959-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>还有一种方式，通过配置registry的proxy来达到同样目的。 详情<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@url</span>-[https://docs.docker.com/registry/recipes/mirror/#run-a-registry-as-a-pull-through-cache]看这里。 \n\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h2</span>-搭建本地Docker库\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h3</span>-使用registry镜像创建私有仓库 <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@tab</span>-\\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h4</span>-获取registry镜像\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; docker pull registry]@\\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h4</span>-通过registr镜像启动一个容器\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; docker run -d -p 5000:5000 -v <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fc</span>-green-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>本地目录 :<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fc</span>-orange-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>/var/lib/registry  registry # <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@i</span>--v  参数将镜像文件存放于本地目录中。不加这个参数默认会存放在容器的 <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@i</span>-/var/lib/registry&amp;nbsp;(v1中是/tmp/registry)  目录下，容器被删，镜像也就没了。]@ \n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@tip</span>-@[<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fc</span>-red-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>PS:  <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>-v  参数用于创建一个容器的数据卷。如: <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>docker&amp;nbsp;run&amp;nbsp;-d&amp;nbsp;-P&amp;nbsp;--name&amp;nbsp;web&amp;nbsp;-v&amp;nbsp;/webapp&amp;nbsp;springboot&amp;nbsp;bash  表示使用 <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-springboot  镜像创建一个名为 <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-web  \n的容器，并创建一个数据卷挂载到容器的<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-/webapp  目录。&lt;br&gt;\n还有一中用法就是像上面的一样，将本机中的目录挂载到容器目录中作为一个数据卷。]@ \n这时，私有仓库就在本地启动了，监听的端口号为5000。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h4</span>-将准备好的要上传到私有仓库的镜像标记\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[# 格式：docker tag REPOSITY【:TAG】 【私有仓库地址(包括端口)/】<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fc</span>-lightgray-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>【USERNAME/】 NAME【:TAG】 \n# 如：将如下镜像centos上传到私有仓库为 p-centos\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\ncentos              1.0                 745059f48e59        2 weeks ago         504 MB\n&gt; docker tag centos:1.0 192.168.1.166:5000/p-centos\n&gt; docker push 192.169.1.166:5000/p-centos # 上传标记镜像到私有仓库]@ \\\n然而事情并非那么顺利。出现如下错误：\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@tip</span>-@[http: server gave HTTP response to HTTPS client]@ 因为docker registry 采用了https协议。解决办法如下：（不同Linux系统，不同版本的docker解决方法可能不相同）\n在 <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>/etc/docker/daemon.json  中添加<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@tip</span>-@[&amp;quot;insecure-registries&amp;quot;:[&amp;quot;192.168.67.129:5000&amp;quot;]]@\\\n相当于一个“白名单”。\n之后依次执行如下命令：<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; systemctl daemon-reload\n&gt; systemctl restart docker]@\\\n重新启动registry容器。然后发现就可以推送镜像了。\n值得注意的是由于docker重新启动，所以registry私人仓库镜像会被关闭，如果没有启动就推送，就会出现：\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@tip</span>-@[dial tcp 192.168.67.129:5000: getsockopt: connection refused]@ \\\n\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h3</span>-本地安装运行私有仓库（非镜像方式）\ndocker-registry源码和配置说明都在这里 -&gt; <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@url</span>-[https://github.com/docker/docker-registry]docker&amp;nbsp;registry&amp;nbsp;source \n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-安装必要的软件\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; yum install -y python-devel libevent-devel python-pip gcc xz-devel openssl-devel\n&gt; pip install gunicorn pyyaml flask flask-cors rsa gevent # gunicorn flask 是部署工具，一般是Python的项目会使用]@\\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-配置安装&amp;nbsp;docker-registry\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; pip install docker-registry]@\\\n很不幸，安装出现了问题。<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@tip</span>-@[building 'M2Crypto.__m2crypto' extension&lt;br&gt;\nswigging SWIG/_m2crypto.i to SWIG/_m2crypto_wrap.c&lt;br&gt;\nswig -python -I/usr/include/python2.7 -I/usr/include -I/usr/include/openssl -includeall -modern -o SWIG/_m2crypto_wrap.c SWIG/_m2crypto.i&lt;br&gt;\nunable to execute swig: No such file or directory]@、\n这个问题出现是因为没有安装<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>swig 。所以要按下面的步骤安装一下：\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; wget https://jaist.dl.sourceforge.net/project/swig/swigwin/swigwin-3.0.12/swigwin-3.0.12.zip #下载安装包 11M左右]@ 、\n这个编译需要gcc环境，所以先不安了，换一种安装方式（悲催的是另一种还是要安装swig）。这个问题参考<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@url</span>-[http://www.linuxidc.com/Linux/2015-12/126517.htm]这里解决。\n另一种安装方式，直接下载源码。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-直接下载源码安装（推荐）\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; yum install -y git\n&gt; git clone https://github.com/docker/docker-registry\n&gt; cd docker-registr\n&gt; cp config/config_sample.yml config/config.yml\n&gt; vi config/config.yml # 修改本地仓库存储路径]@\\\n修改如下字样：\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>-|lightblue-@[\nlocal: &amp;amp;local\n    &amp;lt;&amp;lt;: *common\n    storage: local\n    storage_path: _env:STORAGE_PATH:/home/gemu/software/docker-workspace/data/registry]@\\\n配置好以后安装：\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; python setup.py install]@\\\n启动docker-registry\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; gunicorn --debug \\\n--access-logfile /home/gemu/software/docker-workspace/log/docker-registry/access.log \\\n--error-logfile /home/gemu/software/docker-workspace/log/docker-registry/server.log \\\n-k gevent -b 0.0.0.0:5000 -w 1 docker_registry.wsgi:application]@\\\n好了，下面检验一下成果吧。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[curl 127.0.0.1:5000]@\\\n当我们正要激动的时候发现他喵的启动失败了，什么信息也没回馈（<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-也有可能成功的 ）。一看<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>log/docker-registry/server.log  发现抛了异常。\n说是<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-#fd6565-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>No&amp;nbsp;module&amp;nbsp;named&amp;nbsp;wgsi  。那就参考一下这个<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@url</span>-[https://github.com/docker/docker-registry/issues/397]问题  、<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@url</span>-[https://blog.docker.com/2013/07/how-to-use-your-own-registry/]安装方式。\n\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-关于<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>swig   <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-的问题 \n继续安装swing。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; yum install gcc-c++\nswigwin-3.0.12&gt; ./configure\nswigwin-3.0.12&gt; make &amp;&amp; make install\ndocker-registry&gt; pip install . # 安装docker-registry]@\\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fc</span>-red-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>error -@[swig -python -I/usr/include/python2.7 -I/usr/include -I/usr/include/openssl -includeall -modern -o SWIG/_m2crypto_wrap.c SWIG/_m2crypto.i\n    /usr/include/openssl/opensslconf.h:36: Error: CPP #error &amp;quot;&amp;quot;This openssl-devel package does not work your architecture?&amp;quot;&amp;quot;. Use the -cpperraswarn option to continue swig processing.\n    error: command 'swig' failed with exit status 1\nCommand \"/usr/bin/python2 -u -c \"import setuptools, tokenize;__file__='/tmp/pip-build-FfQB3G/M2Crypto/setup.py';f=getattr(tokenize, 'open', open)(__file__);code=f.read().replace('\\r\\n', '\\n');f.close();exec(compile(code, __file__, 'exec'))\" install --record /tmp/pip-bCEhIb-record/install-record.txt --single-version-externally-managed --compile\" failed with error code 1 in /tmp/pip-build-FfQB3G/M2Crypto/\n]@\\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fc</span>-green-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>solution -@[&gt; env SWIG_FEATURES=&amp;quot;-cpperraswarn -includeall -D__`uname -m`__ -I/usr/include/openssl&amp;quot; pip install .]@\\\n\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-这个启动docker-registry的命令太长了，所以需要配置个服务脚本来启动\n仿照docker.service脚本编写就行了。我的服务脚本文件在<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>/usr/lib/systemd/system  这个目录。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; cp /usr/lib/systemd/system/docker.service /usr/lib/systemd/system/docker-registry.service\n&gt; vi /usr/lib/systemd/system/docker-registry.service\nExecStart=/usr/bin/gunicorn --debug \\\n--access-logfile /home/gemu/software/docker-workspace/log/docker-registry/access.log \\\n--error-logfile /home/gemu/software/docker-workspace/log/docker-registry/server.log \\\n-k gevent -b 0.0.0.0:5000 -w 1 docker_registry.wsgi:application\n]@ 替换如下启动命令就可以了：\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>-|lightblue-@[ExecStart=/usr/bin/gunicorn --debug \\\n--access-logfile /home/gemu/software/docker-workspace/log/docker-registry/access.log \\\n--error-logfile /home/gemu/software/docker-workspace/log/docker-registry/server.log \\\n-k gevent -b 0.0.0.0:5000 -w 1 docker_registry.wsgi:application\n]@\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h2</span>-管理工具\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h3</span>-下载dockerUI\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; docker pull registry.cn-hangzhou.aliyuncs.com/infinitus/dockerui]@ \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h3</span>-运行dockerUI容器\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[&gt; docker run -d -p 9000:9000 --privileged -v /var/run/docker.sock:/var/run/docker.sock registry.cn-hangzhou.aliyuncs.com/infinitus/dockerui \n# <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>--privileged  The --privileged flag is required for hosts using SELinux（Security-Enhanced Linux 安全的Linux子系统）.  ]@ \\\n启动成功后，打开浏览器<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>http://&amp;lt;docker&amp;nbsp;host&amp;nbsp;ip&amp;gt;:9000  查看。\ndocker ui启动后运行的是<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>ui-for-docker  ，它的使用参数如下：\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[Usage of /ui-for-docker:\n  -H string\n        Dockerd endpoint (default \"unix:///var/run/docker.sock\")\n  -a string\n        Path to the assets (default \".\")\n  -d string\n        Path to the data (default \".\")\n  -p string\n        Address and port to serve UI For Docker (default \":9000\")\n  -tlscacert string\n        Path to the CA (default \"/certs/ca.pem\")\n  -tlscert string\n        Path to the TLS certificate file (default \"/certs/cert.pem\")\n  -tlskey string\n        Path to the TLS key (default \"/certs/key.pem\")\n  -tlsverify\n        TLS support\n]@ 这里值得说明的是<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>-H  参数。ui-for-docker 默认会使用<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>/var/run/docker.sock  连接到docker守护进程，这就需要使用 -v 参数来挂载到容器中。所以如果不想将 docker.sock 挂载到容器中，可以使用 -H 可以手动指定socket地址。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@h2</span>-详细解读docker&amp;nbsp;run来管理分配容器资源\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@i</span>-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@url</span>-[https://docs.docker.com/engine/admin/resource_constraints/]官方文档\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>-|#e9efff-@[Usage:  docker run [OPTIONS] IMAGE [COMMAND] [ARG...]\nRun a command in a new container\nOptions:\n      --add-host list                         Add a custom host-to-IP mapping (host:ip) (default [])\n  -a, --attach list                           Attach to STDIN, STDOUT or STDERR (default [])\n      --blkio-weight uint16                   Block IO (relative weight), between 10 and 1000, or 0 to disable (default 0) # 限制磁盘IO\n      --blkio-weight-device weighted-device   Block IO weight (relative device weight) (default []) \n      --cap-add list                          Add Linux capabilities (default [])\n      --cap-drop list                         Drop Linux capabilities (default [])\n      --cgroup-parent string                  Optional parent cgroup for the container\n      --cidfile string                        Write the container ID to the file\n      --cpu-count int                         CPU count (Windows only)\n      --cpu-percent int                       CPU percent (Windows only)\n      --cpu-period int                        Limit CPU CFS (Completely Fair Scheduler) period   # CPU调度周期。指定容器要多久对配额重新做一次分配。单位是微秒（μs）。\n      --cpu-quota int                         Limit CPU CFS (Completely Fair Scheduler) quota   #CPU调度配额，是个绝对值（非加权值）。指定容器在cpu-period指定的时间内最多可以有多久来运行。单位是微秒（μs）\n      --cpu-rt-period int                     Limit CPU real-time period in microseconds\n      --cpu-rt-runtime int                    Limit CPU real-time runtime in microseconds\n  -c, --cpu-shares int                        CPU shares (relative weight)    # 指定CPU配额，是个加权值\n      --cpus decimal                          Number of CPUs (default 0.000)\n      --cpuset-cpus string                    CPUs in which to allow execution (0-3, 0,1)\n      --cpuset-mems string                    MEMs in which to allow execution (0-3, 0,1)\n      --credentialspec string                 Credential spec for managed service account (Windows only)\n  -d, --detach                                Run container in background and print container ID\n      --detach-keys string                    Override the key sequence for detaching a container\n      --device list                           Add a host device to the container (default [])\n      --device-read-bps throttled-device      Limit read rate (bytes per second) from a device (default [])\n      --device-read-iops throttled-device     Limit read rate (IO per second) from a device (default [])\n      --device-write-bps throttled-device     Limit write rate (bytes per second) to a device (default [])\n      --device-write-iops throttled-device    Limit write rate (IO per second) to a device (default [])\n      --disable-content-trust                 Skip image verification (default true)\n      --dns list                              Set custom DNS servers (default [])\n      --dns-option list                       Set DNS options (default [])\n      --dns-search list                       Set custom DNS search domains (default [])\n      --entrypoint string                     Overwrite the default ENTRYPOINT of the image\n  -e, --env list                              Set environment variables (default [])\n      --env-file list                         Read in a file of environment variables (default [])\n      --expose list                           Expose a port or a range of ports (default [])\n      --group-add list                        Add additional groups to join (default [])\n      --health-cmd string                     Command to run to check health\n      --health-interval duration              Time between running the check (ns|us|ms|s|m|h) (default 0s)\n      --health-retries int                    Consecutive failures needed to report unhealthy\n      --health-timeout duration               Maximum time to allow one check to run (ns|us|ms|s|m|h) (default 0s)\n      --help                                  Print usage\n  -h, --hostname string                       Container host name\n      --init                                  Run an init inside the container that forwards signals and reaps processes\n      --init-path string                      Path to the docker-init binary\n  -i, --interactive                           Keep STDIN open even if not attached\n      --io-maxbandwidth string                Maximum IO bandwidth limit for the system drive (Windows only)\n      --io-maxiops uint                       Maximum IOps limit for the system drive (Windows only)\n      --ip string                             Container IPv4 address (e.g. 172.30.100.104)\n      --ip6 string                            Container IPv6 address (e.g. 2001:db8::33)\n      --ipc string                            IPC namespace to use\n      --isolation string                      Container isolation technology\n      --kernel-memory string                  Kernel memory limit\n  -l, --label list                            Set meta data on a container (default [])\n      --label-file list                       Read in a line delimited file of labels (default [])\n      --link list                             Add link to another container (default [])\n      --link-local-ip list                    Container IPv4/IPv6 link-local addresses (default [])\n      --log-driver string                     Logging driver for the container\n      --log-opt list                          Log driver options (default [])\n      --mac-address string                    Container MAC address (e.g. 92:d0:c6:0a:29:33)\n  -m, --memory string                         Memory limit # 设置容器可使用的最大内存上限\n      --memory-reservation string             Memory soft limit\n      --memory-swap string                    Swap limit equal to memory plus swap: '-1' to enable unlimited swap\n      --memory-swappiness int                 Tune container memory swappiness (0 to 100) (default -1)  # 控制进程将物理内存交换到swap分区的倾向。\n      --name string                           Assign a name to the container\n      --network string                        Connect a container to a network (default &amp;quot;default&amp;quot;)\n      --network-alias list                    Add network-scoped alias for the container (default [])\n      --no-healthcheck                        Disable any container-specified HEALTHCHECK\n      --oom-kill-disable                      Disable OOM Killer\n      --oom-score-adj int                     Tune host's OOM preferences (-1000 to 1000)\n      --pid string                            PID namespace to use\n      --pids-limit int                        Tune container pids limit (set -1 for unlimited)\n      --privileged                            Give extended privileges to this container\n  -p, --publish list                          Publish a container's port(s) to the host (default [])\n  -P, --publish-all                           Publish all exposed ports to random ports\n      --read-only                             Mount the container's root filesystem as read only\n      --restart string                        Restart policy to apply when a container exits (default &amp;quot;no&amp;quot;)\n      --rm                                    Automatically remove the container when it exits\n      --runtime string                        Runtime to use for this container\n      --security-opt list                     Security Options (default [])\n      --shm-size string                       Size of /dev/shm, default value is 64MB\n      --sig-proxy                             Proxy received signals to the process (default true)\n      --stop-signal string                    Signal to stop a container, SIGTERM by default (default &amp;quot;SIGTERM&amp;quot;)\n      --stop-timeout int                      Timeout (in seconds) to stop a container\n      --storage-opt list                      Storage driver options for the container (default [])\n      --sysctl map                            Sysctl options (default map[])\n      --tmpfs list                            Mount a tmpfs directory (default [])\n  -t, --tty                                   Allocate a pseudo-TTY\n      --ulimit ulimit                         Ulimit options (default [])\n  -u, --user string                           Username or UID (format: &amp;lt;name|uid&amp;gt;[:&amp;lt;group|gid&amp;gt;])\n      --userns string                         User namespace to use\n      --uts string                            UTS namespace to use\n  -v, --volume list                           Bind mount a volume (default [])\n      --volume-driver string                  Optional volume driver for the container\n      --volumes-from list                     Mount volumes from the specified container(s) (default [])\n  -w, --workdir string                        Working directory inside the container]@ \n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@url</span>-[http://blog.csdn.net/lc0817/article/details/52035596]参考这里\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-CPU\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>--cpu-shares  分配容器运行的CPU配额，默认值为1024，它的是是一个加权值，单独一个是没有意义的，多个容器一起运行时，才有意义。 比如A、B两个容器，分配的配额分别是1000和500，那么在CPU进行时间分片的时候，A容器比B容器多一倍的机会获取到CPU时间片。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>--cpu-period  CPU调度周期。指定容器要多久对配额重新做一次分配。单位是微秒（μs）。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>--cpu-quota  CPU调度配额，是个绝对值（非加权值）。指定容器在cpu-period指定的时间内最多可以有多久来运行。单位是微秒（μs） 。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>--memory-swap  内存和swap的总和。这个值只有在-memory设置的时候才有意义。为了方便理解，官网上举了几个例子来说明。如下:<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@tab</span>-\\\n若<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-#F5F8FA-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>--memory-swap  的值是一个正数，那么<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-#F5F8FA-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>--memory  的值也必须设置。<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-#F5F8FA-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>--memory  控制的是非swap分区内存的大小。而<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-#F5F8FA-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>--memory-swap  控制的是非swap分区内存和swap分区内存的总和。\\\n如：<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-#F5F8FA-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>--memory=\"300m\"  <span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-#F5F8FA-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>--memory-swap=\"1g\"  。那么容器能使用300m的内存和700m（1g - 300m）的swap空间。\n若<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-#F5F8FA-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>--memory-swap  的值设为0或者值和<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-#F5F8FA-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>--memory  相等。那么这个设置将会被忽略，没有意义。\n若<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-#F5F8FA-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>--memory-swap  没有指定值，但是<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-#F5F8FA-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>--memory  有个正数值，那么将会分配给swap空间两倍的内存空间大小。如：<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-#F5F8FA-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>--memory=\"300m\"  ，但是<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-#F5F8FA-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>--memory-swap  没有设置值。那么容器能使用300m的内存和600m的swap空间。\n若<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-#F5F8FA-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>--memory-swap  的值设置为-1。那么表示容器将不被限制使用swap空间。直到主机达到上限。\n\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-内存\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>--memory-swappiness  控制进程将物理内存交换到swap分区的倾向百分比，默认系数为-1。系数越小，就越倾向于使用物理内存。值范围为0-100。当值为100时，表示尽量使用swap分区；当值为0时，表示禁用容器 swap 功能(这点不同于宿主机，\\\n宿主机 swappiness 设置为 0 也不保证 swap 不会被使用)。<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@i</span>-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fc</span>-blue-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>swap分区   是在物理内存不足时，把硬盘的一些可能很久没有用到的空间清理出来，以便系统正常运行。这些被清理出来的数据就被保存到了swap分区中，当用到的时候，就从swap分区中恢复保存的数据到内存中。\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>--memory  设置容器可使用的最大内存。单位默认是byte。可以使用K、M、G等带有单位的字符串。\n\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fc</span>-red-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>PS:  使用Docker自带的-m操作进行内存限制时可能会由于内核限制所以出现以下提示\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>-|red-@[Your kernel does not support swap limit capabilities.memory limit without swap]@ \\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@url</span>-[http://blog.csdn.net/l6807718/article/details/51692827]点击访问以下内容来源\n需要通过修改grub文件/etc/default/grub 添加：\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@fbc</span>-yellow-<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\">&gt;</span>GRUB_CMDLINE_LINUX=&amp;quot;cgroup_enable=memory&amp;nbsp;swapaccount=1&amp;quot;\n之后更新grub并重启可以解决\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[$ sudo update-grub\n$ sudo reboot\n]@\\\n使用docker -m操作会使内存被限制为输入大小的两倍\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[\n$ sudo docker run -it --name test -m 100m ubuntu /bin/bash # 此时内存被限制为200m]@\\\n若想要限制为100m必须执行\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@code</span>--@[$ sudo docker run -it --name test -m 100m --memory-swap=100m ubuntu /bin/bash # 此时内存与swap都被限制为100m]@\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-磁盘IO\n相对于CPU和内存的配额控制，docker对磁盘IO的控制相对不成熟，大多数都必须在有宿主机设备的情况下使用。主要包括以下参数：\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@ul</span>-(#device-read-bps：限制此设备上的读速度（bytes per second），单位可以是kb、mb或者gb。#device-read-iops：通过每秒读IO次数来限制指定设备的读速度。#device-write-bps ：限制此设备上的写速度（bytes per second），单位可以是kb、mb或者gb。#device-write-iops：通过每秒写IO次数来限制指定设备的写速度。#blkio-weight：容器默认磁盘IO的加权值，有效值范围为10-100。#blkio-weight-device： 针对特定设备的IO加权控制。其格式为DEVICE_NAME:WEIGHT)\\\n<span style=\"font-style: italic; color: #00c0ff;\" contenteditable=\"false\" class=\"\">@b</span>-Docker容器空间大小限制\n在docker使用devicemapper作为存储驱动时，默认每个容器和镜像的最大大小为10G。如果需要调整，可以在daemon启动参数中，使用dm.basesize来指定，但需要注意的是，修改这个值，不仅仅需要重启docker daemon服务，还会导致宿主机上的所有本地镜像和容器都被清理掉。\n使用aufs或者overlay等其他存储驱动时，没有这个限制。\nso on\n</pre>",
  "noteName": "2017-4-24",
  "tags": "Docker"
}